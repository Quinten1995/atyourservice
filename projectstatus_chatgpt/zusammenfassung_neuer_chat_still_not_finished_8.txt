# Zusammenfassung für neuen Chat: „atyourservice“ Flutter-App mit Supabase

## Ziel des neuen Chats
Wir möchten den aktuellen Stand der Implementierung der „atyourservice“-App zusammenfassen und den Punkt klären, an dem es derzeit hakt: 
- Der Kunde sieht **nicht** die Kontaktdaten des Dienstleisters, sobald der Auftrag vom Dienstleister angenommen wurde.

## Aktueller Ablauf (gewünschtes Verhalten)
1. **Kunde:** Erstellt einen Auftrag (inklusive Telefonnummer).
2. **Dienstleister:** Sieht in seinem Dashboard passende Aufträge, klickt auf einen und sieht zunächst Auftragstext + Status.
3. **Dienstleister:** Drückt „Auftrag annehmen“.
   - Die Spalte `status` in der Tabelle „auftraege” wird auf `in bearbeitung` gesetzt.
   - Die Spalte `dienstleister_id` wird mit der ID des DL befüllt.
   - DL sieht dann in der Detailansicht die Kontaktdaten des Kunden.
4. **Kunde:** Wenn er dieselbe Auftrag-Detailansicht neu lädt, wird der Status „in bearbeitung“ angezeigt – und der Kunde soll nun die Kontaktdaten des Dienstleisters (Telefon + E-Mail) sehen.

**Status jetzt:** 
- Dienstleister sieht nach Annehmen des Auftrags die Kontaktdaten des Kunden.
- Kunde sieht nach Annehmen zwar den Status „in bearbeitung“, aber unter „Dienstleisterkontakt:“ fehlen die Felder Telefon + E-Mail (sie bleiben leer).

## Bisherige Debug-Versuche
- RLS (Row-Level-Security) für Tabellen **`auftraege`** und **`dienstleister_details`** vorübergehend deaktiviert → kein Unterschied.
- Unterschiedliche Varianten des Joins ausprobiert (verschachteltes `select('… kunde:users!… dienstleister:users!…')` und vereinfachte Variante) – beides führte nicht zur Anzeige des Dienstleisterkontakts im Kunden-View.
- Direkte Überprüfung in der DB per SQL (SELECT auf `dienstleister_details WHERE user_id = <DL-ID>`) liefert eine Zeile (also der Datensatz existiert).
- Einfügen von `print(...)`-Statements in `_ladeRolleUndAktuellenAuftrag()` und `_auftragAnnehmen()`, um zu prüfen, ob `dlUserRow` und `dlDetailsRow` wirklich Daten enthalten. Ergebnis: `dlUserRow` und `dlDetailsRow` kommen teilweise als `null` zurück, weil der Datensatz in `dienstleister_details` (telefonfeld) manchmal fehlt bzw. unterschätzt wurde.

**Fazit:**  
Der wesentliche Grund dafür, dass im Kunden-View die DL-Kontaktdaten nicht angezeigt werden, ist:  
- Entweder es existiert kein Eintrag in `dienstleister_details` für genau jene `user_id` (Dienstleister),  
- oder die Logik im Code, die die Daten abfragt, wurde noch nicht vollständig angepasst.  

### Vorschlag zur vereinfachten Lösung
Anstatt das verschachtelte Embedding (`select('… kunde:users!… dienstleister:users!…')`) zu verwenden, wurde empfohlen, **zwei einfache Abfragen** nacheinander durchzuführen:
1. Basisdaten des Auftrags aus **`auftraege`** abfragen (inkl. `status`, `telefon`, `kunde_id`, `dienstleister_id`).
2. Falls `status == 'in bearbeitung'` und wir den DL-Kontakt benötigen (im Kunden-View):
   - E-Mail des Dienstleisters aus `users WHERE id = dienstleister_id`
   - Telefonnummer des Dienstleisters aus `dienstleister_details WHERE user_id = dienstleister_id`

Damit ist das Verhalten eindeutig und leichter zu debuggen.

---

## Relevante Skripte (kompletter Kontext)

### 1. Modell-Klassen

#### models/auftrag.dart
```dart
class Auftrag {
  final String id;
  final String kundeId;
  final String? dienstleisterId;
  final String titel;
  final String beschreibung;
  final String kategorie;
  final String? adresse;
  final double? latitude;
  final double? longitude;
  final String status;
  final DateTime erstelltAm;
  final DateTime aktualisiertAm;
  final String? telefon; // neu

  Auftrag({
    required this.id,
    required this.kundeId,
    this.dienstleisterId,
    required this.titel,
    required this.beschreibung,
    required this.kategorie,
    this.adresse,
    this.latitude,
    this.longitude,
    required this.status,
    required this.erstelltAm,
    required this.aktualisiertAm,
    this.telefon,
  });

  factory Auftrag.fromJson(Map<String, dynamic> json) => Auftrag(
        id: json['id'] as String,
        kundeId: json['kunde_id'] as String,
        dienstleisterId: json['dienstleister_id'] as String?,
        titel: json['titel'] as String,
        beschreibung: json['beschreibung'] as String,
        kategorie: json['kategorie'] as String,
        adresse: json['adresse'] as String?,
        latitude: (json['latitude'] as num?)?.toDouble(),
        longitude: (json['longitude'] as num?)?.toDouble(),
        status: json['status'] as String,
        erstelltAm: DateTime.parse(json['erstellt_am'] as String),
        aktualisiertAm: DateTime.parse(json['aktualisiert_am'] as String),
        telefon: json['telefon'] as String?, // wird hier eingelesen
      );

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{
      'id': id,
      'kunde_id': kundeId,
      'titel': titel,
      'beschreibung': beschreibung,
      'kategorie': kategorie,
      'status': status,
      'erstellt_am': erstelltAm.toIso8601String(),
      'aktualisiert_am': aktualisiertAm.toIso8601String(),
    };
    if (dienstleisterId != null) {
      map['dienstleister_id'] = dienstleisterId;
    }
    if (adresse != null) {
      map['adresse'] = adresse;
    }
    if (latitude != null) {
      map['latitude'] = latitude;
    }
    if (longitude != null) {
      map['longitude'] = longitude;
    }
    if (telefon != null) {
      map['telefon'] = telefon;
    }
    return map;
  }
}
```

#### models/dienstleister.dart
```dart
class Dienstleister {
  final String id;
  final String name;
  final String kategorie;
  final double latitude;
  final double longitude;
  final DateTime zuletztOnline;
  final String? telefon; // neu
  final String? email;   // neu, falls gewünscht

  Dienstleister({
    required this.id,
    required this.name,
    required this.kategorie,
    required this.latitude,
    required this.longitude,
    required this.zuletztOnline,
    this.telefon,
    this.email,
  });

  factory Dienstleister.fromJson(Map<String, dynamic> json) => Dienstleister(
        id: json['user_id'] as String,
        name: json['name'] as String,
        kategorie: json['kategorie'] as String,
        latitude: (json['latitude'] as num?)?.toDouble() ?? 0.0,
        longitude: (json['longitude'] as num?)?.toDouble() ?? 0.0,
        zuletztOnline: DateTime.parse(json['aktualisiert_am'] as String),
        telefon: json['telefon'] as String?,
        email: json['email'] as String?,
      );

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{
      'user_id': id,
      'name': name,
      'kategorie': kategorie,
      'latitude': latitude,
      'longitude': longitude,
      'aktualisiert_am': zuletztOnline.toIso8601String(),
    };
    if (telefon != null) {
      map['telefon'] = telefon;
    }
    if (email != null) {
      map['email'] = email;
    }
    return map;
  }
}
```

### 2. AuftragDetailScreen (aktuelle Version)

> **Hinweis:** Dies ist die derzeit verwendete Variante mit verschachtelten Joins. Sie funktioniert teilweise, liefert für den Kunden aber keine DL-Kontaktdaten. In einem neuen Chat würde empfohlen, auf die vereinfachte, zweistufige Abfrage umzusteigen (siehe Abschnitt „Vereinfachte Lösung“ weiter unten).

```dart
// lib/screens/auftrag_detail_screen.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/auftrag.dart';

class AuftragDetailScreen extends StatefulWidget {
  final Auftrag initialAuftrag;
  const AuftragDetailScreen({Key? key, required this.initialAuftrag})
      : super(key: key);

  @override
  _AuftragDetailScreenState createState() => _AuftragDetailScreenState();
}

class _AuftragDetailScreenState extends State<AuftragDetailScreen> {
  Auftrag? _auftragDetails;
  bool _isLoading = false;
  String? _errorMessage;
  bool _isDienstleister = false;
  final SupabaseClient _supabase = Supabase.instance.client;

  // Felder für Kontakte
  String? _kundenTelefon;
  String? _kundenEmail;
  String? _dlTelefon;
  String? _dlEmail;

  @override
  void initState() {
    super.initState();
    _auftragDetails = widget.initialAuftrag;
    _ladeRolleUndAktuellenAuftrag();
  }

  Future<void> _ladeRolleUndAktuellenAuftrag() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final user = _supabase.auth.currentUser;
      if (user == null) throw Exception('Nicht eingeloggt');

      // 1) Rolle des aktuellen Nutzers abfragen
      final roleData = await _supabase
          .from('users')
          .select('rolle')
          .eq('id', user.id)
          .maybeSingle() as Map<String, dynamic>?;
      if (roleData == null || roleData['rolle'] == null) {
        throw Exception('Rolle konnte nicht ermittelt werden');
      }
      _isDienstleister = (roleData['rolle'] as String) == 'dienstleister';

      // 2) Neuesten Auftrag mit Join-Abfrage laden
      final data = await _supabase
          .from('auftraege')
          .select('''
            id,
            titel,
            beschreibung,
            kategorie,
            adresse,
            latitude,
            longitude,
            status,
            erstellt_am,
            aktualisiert_am,
            telefon,
            kunde:users!auftraege_kunde_id_fkey(email),
            dienstleister:users!auftraege_dienstleister_id_fkey(
              dienstleister_details!dienstleister_details_user_id_fkey(telefon,email)
            ),
            kunde_id,
            dienstleister_id
          ''')
          .eq('id', widget.initialAuftrag.id)
          .maybeSingle() as Map<String, dynamic>?;

      // ─── DEBUG: komplette Rückgabe von Supabase ausgeben ───
      print('▶▶ DEBUG AuftragDetail data (kunde‐View): $data');

      if (data == null) {
        throw Exception('Auftrag nicht gefunden');
      }

      // 3) Core-Auftragsdaten in Auftrag-Model umwandeln
      _auftragDetails = Auftrag.fromJson(data);

      // 4) Kunden-Kontakt: telefon aus auftraege, email aus eingebettetem 'kunde'
      _kundenTelefon = data['telefon'] as String?;
      final kundeRaw = data['kunde'];
      if (kundeRaw is Map<String, dynamic>) {
        _kundenEmail = kundeRaw['email'] as String?;
      } else {
        _kundenEmail = null;
      }

      // 5) Dienstleister-Kontakt: nur dann auslesen, wenn überhaupt ein Eintrag existiert
      final dlRaw = data['dienstleister'];
      if (dlRaw is Map<String, dynamic>) {
        // dlRaw enthält den User‐Eintrag, in dem wiederum 'dienstleister_details' als Liste vorliegt
        final detailsRaw = dlRaw['dienstleister_details'];
        if (detailsRaw is List<dynamic> && detailsRaw.isNotEmpty) {
          final detailsMap = detailsRaw.first;
          if (detailsMap is Map<String, dynamic>) {
            _dlTelefon = detailsMap['telefon'] as String?;
            _dlEmail = detailsMap['email'] as String?;
          } else {
            _dlTelefon = null;
            _dlEmail = null;
          }
        } else {
          _dlTelefon = null;
          _dlEmail = null;
        }
      } else {
        _dlTelefon = null;
        _dlEmail = null;
      }

    } on PostgrestException catch (e) {
      // Die Message aus e.message zeigt den Postgrest-Fehler an
      _errorMessage = e.message;
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  Future<void> _auftragAnnehmen() async {
    if (_auftragDetails == null) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final user = _supabase.auth.currentUser;
      if (user == null) throw Exception('Nicht eingeloggt');

      // Beim Annehmen den Datensatz updaten und JOIN-Abfrage durchführen
      final data = await _supabase
          .from('auftraege')
          .update({
            'status': 'in bearbeitung',
            'dienstleister_id': user.id,
            'aktualisiert_am': DateTime.now().toUtc().toIso8601String(),
          })
          .eq('id', _auftragDetails!.id)
          .select('''
            id,
            titel,
            beschreibung,
            kategorie,
            adresse,
            latitude,
            longitude,
            status,
            erstellt_am,
            aktualisiert_am,
            telefon,
            kunde:users!auftraege_kunde_id_fkey(email),
            dienstleister:users!auftraege_dienstleister_id_fkey(
              dienstleister_details!dienstleister_details_user_id_fkey(telefon,email)
            ),
            kunde_id,
            dienstleister_id
          ''')
          .maybeSingle() as Map<String, dynamic>?;

      if (data == null) {
        throw Exception('Fehler beim Annehmen');
      }

      _auftragDetails = Auftrag.fromJson(data);

      // Kunden-Kontakt neu extrahieren
      _kundenTelefon = data['telefon'] as String?;
      final kundeRaw = data['kunde'];
      if (kundeRaw is Map<String, dynamic>) {
        _kundenEmail = kundeRaw['email'] as String?;
      } else {
        _kundenEmail = null;
      }

      // Dienstleister-Kontakt neu extrahieren
      final dlRaw = data['dienstleister'];
      if (dlRaw is Map<String, dynamic>) {
        final detailsRaw = dlRaw['dienstleister_details'];
        if (detailsRaw is List<dynamic> && detailsRaw.isNotEmpty) {
          final detailsMap = detailsRaw.first;
          if (detailsMap is Map<String, dynamic>) {
            _dlTelefon = detailsMap['telefon'] as String?;
            _dlEmail = detailsMap['email'] as String?;
          } else {
            _dlTelefon = null;
            _dlEmail = null;
          }
        } else {
          _dlTelefon = null;
          _dlEmail = null;
        }
      } else {
        _dlTelefon = null;
        _dlEmail = null;
      }

      _isDienstleister = true;
    } on PostgrestException catch (e) {
      _errorMessage = e.message;
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }  

  Future<void> _auftragAbschliessen() async {
    if (_auftragDetails == null) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final data = await _supabase
          .from('auftraege')
          .update({
            'status': 'abgeschlossen',
            'aktualisiert_am': DateTime.now().toUtc().toIso8601String(),
          })
          .eq('id', _auftragDetails!.id)
          .select('''
            id,
            titel,
            beschreibung,
            kategorie,
            adresse,
            latitude,
            longitude,
            status,
            erstellt_am,
            aktualisiert_am,
            telefon,
            kunde:users!auftraege_kunde_id_fkey(email),
            dienstleister:users!auftraege_dienstleister_id_fkey(
              dienstleister_details!dienstleister_details_user_id_fkey(telefon,email)
            ),
            kunde_id,
            dienstleister_id
          ''')
          .maybeSingle() as Map<String, dynamic>?;

      if (data == null) {
        throw Exception('Fehler beim Abschließen');
      }

      _auftragDetails = Auftrag.fromJson(data);
    } on PostgrestException catch (e) {
      _errorMessage = e.message;
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Auftragsdetails')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: _isLoading
            ? const Center(child: CircularProgressIndicator())
            : _auftragDetails == null
                ? const Center(child: Text('Keine Daten verfügbar'))
                : SingleChildScrollView(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // Titel anzeigen
                        Text(
                          _auftragDetails!.titel,
                          style: const TextStyle(
                              fontSize: 22, fontWeight: FontWeight.bold),
                        ),
                        const SizedBox(height: 12),

                        // Beschreibung
                        Text('Beschreibung: ${_auftragDetails!.beschreibung}'),
                        const SizedBox(height: 8),

                        // Kategorie
                        Text('Kategorie: ${_auftragDetails!.kategorie}'),
                        const SizedBox(height: 8),

                        // Adresse (falls vorhanden)
                        if (_auftragDetails!.adresse != null) ...[
                          Text('Adresse: ${_auftragDetails!.adresse!}'),
                          const SizedBox(height: 8),
                        ],

                        // Standort (falls vorhanden)
                        if (_auftragDetails!.latitude != null &&
                            _auftragDetails!.longitude != null) ...[
                          Text(
                              'Standort: ${_auftragDetails!.latitude}, ${_auftragDetails!.longitude}'),
                          const SizedBox(height: 8),
                        ],

                        const SizedBox(height: 16),
                        Row(
                          children: [
                            const Text('Status:'),
                            const SizedBox(width: 12),
                            Text(_auftragDetails!.status),
                          ],
                        ),
                        const SizedBox(height: 24),

                        // Kontaktdaten anzeigen, sobald status == 'in bearbeitung'
                        if (_auftragDetails!.status == 'in bearbeitung') ...[
                          if (_isDienstleister) ...[
                            const Divider(),
                            const Text(
                              'Kundenkontakt:',
                              style: TextStyle(fontWeight: FontWeight.bold),
                            ),
                            const SizedBox(height: 4),
                            if (_kundenTelefon != null && _kundenTelefon!.isNotEmpty)
                              Text('Telefon: $_kundenTelefon'),
                            if (_kundenEmail != null && _kundenEmail!.isNotEmpty)
                              Text('E-Mail: $_kundenEmail'),
                            const SizedBox(height: 16),
                          ],
                          if (!_isDienstleister) ...[
                            const Divider(),
                            const Text(
                              'Dienstleisterkontakt:',
                              style: TextStyle(fontWeight: FontWeight.bold),
                            ),
                            const SizedBox(height: 4),
                            if (_dlTelefon != null && _dlTelefon!.isNotEmpty)
                              Text('Telefon: $_dlTelefon'),
                            if (_dlEmail != null && _dlEmail!.isNotEmpty)
                              Text('E-Mail: $_dlEmail'),
                            const SizedBox(height: 16),
                          ],
                        ],

                        if (!_isLoading && _auftragDetails != null) ...[
                          // Button „Auftrag annehmen“
                          if (_isDienstleister &&
                              _auftragDetails!.status == 'offen')
                            ElevatedButton(
                              onPressed: _auftragAnnehmen,
                              child: const Text('Auftrag annehmen'),
                            ),

                          // Button „Auftrag abschließen“
                          if (_isDienstleister &&
                              _auftragDetails!.status == 'in bearbeitung' &&
                              _auftragDetails!.dienstleisterId ==
                                  _supabase.auth.currentUser!.id)
                            Padding(
                              padding: const EdgeInsets.only(top: 12.0),
                              child: ElevatedButton(
                                onPressed: _auftragAbschliessen,
                                child: const Text('Auftrag abschließen'),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Colors.green,
                                ),
                              ),
                            ),  
                        ],

                        if (_errorMessage != null) ...[
                          const SizedBox(height: 16),
                          Text(
                            'Fehler: $_errorMessage',
                            style: const TextStyle(color: Colors.red),
                          ),
                        ],  
                      ],  
                    ),  
                  ),  
      ),  
    );  
  }  
}
```

> **Wichtig:** Der oben gezeigte Code ist noch die „verschränkte Join“-Variante, die im Kunden‐View keine DL‐Kontaktdaten liefert. Wir wollen bei einem neuen Chat stattdessen auf diese vereinfachte Logik umsteigen:

```dart
// Pseudocode für vereinfachte Abfrage im neuen Ansatz
Auftragsdaten = await supabase
  .from('auftraege')
  .select('id, titel, beschreibung, ..., telefon, kunde_id, dienstleister_id')
  .eq('id', <auftragId>)
  .maybeSingle();

if (Auftragsdaten.status == 'in bearbeitung') {
  if (aktuellerUserIstDienstleister) {
    // Kunde-Email holen
    KundenEmailRow = await supabase
      .from('users')
      .select('email')
      .eq('id', Auftragsdaten.kunde_id)
      .maybeSingle();
    KundenEmail = KundenEmailRow['email'];
  } else {
    // DL-E-Mail holen
    DLUserRow = await supabase
      .from('users')
      .select('email')
      .eq('id', Auftragsdaten.dienstleister_id)
      .maybeSingle();
    DLEmail = DLUserRow['email'];

    // DL-Telefon holen
    DLDetailsRow = await supabase
      .from('dienstleister_details')
      .select('telefon')
      .eq('user_id', Auftragsdaten.dienstleister_id)
      .maybeSingle();
    DLTTelefon = DLDetailsRow['telefon'];
  }
}
```

---

### 3. AuftragErstellenScreen

```dart
// lib/screens/auftrag_erstellen_screen.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:uuid/uuid.dart';
import 'package:atyourservice/utils/geocoding_service.dart';

class AuftragErstellenScreen extends StatefulWidget {
  const AuftragErstellenScreen({Key? key}) : super(key: key);

  @override
  _AuftragErstellenScreenState createState() => _AuftragErstellenScreenState();
}

class _AuftragErstellenScreenState extends State<AuftragErstellenScreen> {
  final _supabase = Supabase.instance.client;
  final _formKey = GlobalKey<FormState>();

  // Controller für Formular-Felder
  final _titelController = TextEditingController();
  final _beschreibungController = TextEditingController();
  String _selectedKategorie = 'Elektriker'; // Standard-Kategorie
  final _adresseController = TextEditingController();
  final _telefonController = TextEditingController(); // neu

  bool _isLoading = false;
  String? _errorMessage;

  Future<void> _auftragAbschicken() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final user = _supabase.auth.currentUser;
      if (user == null) {
        throw Exception('Bitte zuerst einloggen');
      }

      final adresse = _adresseController.text.trim();
      final telefon = _telefonController.text.trim(); // neu
      double? lat;
      double? lon;

      if (adresse.isNotEmpty) {
        // Adresse per Geocoding in Koordinaten umwandeln
        final coords = await GeocodingService().getCoordinates(adresse);
        if (coords == null) {
          throw Exception('Adresse nicht gefunden. Bitte prüfen.');
        }
        lat = coords['lat'];
        lon = coords['lng'];
      }

      // Upsert in users (falls noch nicht vorhanden)
      try {
        await _supabase.from('users').upsert({
          'id': user.id,
          'email': user.email,
          'rolle': 'kunde',
          'erstellt_am': DateTime.now().toUtc().toIso8601String(),
        });
      } catch (_) {
        // Ignoriere Fehler, falls schon vorhanden
      }

      final String id = const Uuid().v4();
      final timestamp = DateTime.now().toUtc().toIso8601String();

      // Führe den Insert aus, inkl. neuem Feld 'telefon'
      await _supabase.from('auftraege').insert({
        'id': id,
        'kunde_id': user.id,
        'titel': _titelController.text.trim(),
        'beschreibung': _beschreibungController.text.trim(),
        'kategorie': _selectedKategorie,
        'adresse': adresse.isEmpty ? null : adresse,
        'latitude': lat,
        'longitude': lon,
        'status': 'offen',
        'erstellt_am': timestamp,
        'aktualisiert_am': timestamp,
        'telefon': telefon, // Kundentelefon wird hier gesetzt
      });

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Auftrag wurde erfolgreich gespeichert!')),
      );
      Navigator.pop(context);
    } on Exception catch (e) {
      setState(() {
        _errorMessage = e.toString().replaceFirst('Exception: ', '');
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _errorMessage = 'Unbekannter Fehler: $e';
        _isLoading = false;
      });
    }
  }

  @override
  void dispose() {
    _titelController.dispose();
    _beschreibungController.dispose();
    _adresseController.dispose();
    _telefonController.dispose(); // neu
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Neuen Auftrag erstellen')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: _isLoading
            ? const Center(child: CircularProgressIndicator())
            : SingleChildScrollView(
                child: Form(
                  key: _formKey,
                  child: Column(
                    children: [
                      TextFormField(
                        controller: _titelController,
                        decoration: const InputDecoration(labelText: 'Titel'),
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Bitte Titel eingeben';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _beschreibungController,
                        decoration: const InputDecoration(labelText: 'Beschreibung'),
                        maxLines: 3,
                      ),
                      const SizedBox(height: 16),
                      DropdownButtonFormField<String>(
                        value: _selectedKategorie,
                        decoration: const InputDecoration(labelText: 'Kategorie'),
                        items: const [
                          DropdownMenuItem(value: 'Elektriker', child: Text('Elektriker')),
                          DropdownMenuItem(value: 'Klempner', child: Text('Klempner')),
                          DropdownMenuItem(value: 'Maler', child: Text('Maler')),
                          // Weitere Kategorien nach Bedarf
                        ],
                        onChanged: (wert) {
                          if (wert != null) {
                            setState(() {
                              _selectedKategorie = wert;
                            });
                          }
                        },
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _adresseController,
                        decoration: const InputDecoration(
                          labelText: 'Adresse (z. B. Alter Markt 76, 50667 Koeln)',
                        ),
                        validator: (value) {
                          // Adresse ist optional
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _telefonController,
                        decoration: const InputDecoration(labelText: 'Telefonnummer'),
                        keyboardType: TextInputType.phone,
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Bitte Telefonnummer eingeben';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 24),
                      if (_errorMessage != null) ...[
                        Text(
                          'Fehler: $_errorMessage',
                          style: const TextStyle(color: Colors.red),
                        ),
                        const SizedBox(height: 12),
                      ],
                      ElevatedButton(
                        onPressed: _auftragAbschicken,
                        child: const Text('Auftrag abschicken'),
                      ),
                    ],
                  ),
                ),
              ),
      ),
    );
  }
}
```

### 4. DienstleisterDashboardScreen

```dart
// lib/screens/dienstleister_dashboard_screen.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'profil_dienstleister_screen.dart' as p;
import 'auftrag_detail_screen.dart' as a;
import '../models/auftrag.dart';
import '../utils/entfernung_utils.dart';

class DienstleisterDashboardScreen extends StatefulWidget {
  const DienstleisterDashboardScreen({Key? key}) : super(key: key);

  @override
  _DienstleisterDashboardScreenState createState() =>
      _DienstleisterDashboardScreenState();
}

class _DienstleisterDashboardScreenState
    extends State<DienstleisterDashboardScreen> {
  final SupabaseClient _supabase = Supabase.instance.client;
  String? _meineKategorie;
  double? _meineLatitude;
  double? _meineLongitude;
  List<Auftrag> _passendeAuftraege = [];
  bool _isLoading = true;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _ladeProfilUndAuftraege();
  }

  Future<void> _ladeProfilUndAuftraege() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final user = _supabase.auth.currentUser!;

      // 1) Profil-Daten laden
      final profildata = await _supabase
          .from('dienstleister_details')
          .select('kategorie, latitude, longitude')
          .eq('user_id', user.id)
          .maybeSingle() as Map<String, dynamic>?;
      if (profildata == null) {
        throw Exception('Bitte zunächst dein Profil anlegen');
      }
      _meineKategorie = profildata['kategorie'] as String?;
      _meineLatitude = (profildata['latitude'] as num?)?.toDouble();
      _meineLongitude = (profildata['longitude'] as num?)?.toDouble();

      if (_meineKategorie == null ||
          _meineLatitude == null ||
          _meineLongitude == null) {
        throw Exception('Unvollständiges Profil: Kategorie oder Standort fehlt');
      }

      // 2) Alle offenen Aufträge derselben Kategorie laden
      final daten = await _supabase
          .from('auftraege')
          .select('*')
          .eq('kategorie', _meineKategorie!)
          .eq('status', 'offen')
          .order('erstellt_am', ascending: false);
      final alleAuftraege = (daten as List)
          .map((json) => Auftrag.fromJson(json as Map<String, dynamic>))
          .toList();

      // 3) Lokal filtern nach Entfernung ≤ 50 km
      final gefiltert = alleAuftraege.where((a) {
        if (a.latitude == null || a.longitude == null) return false;
        final dist = berechneEntfernung(
          _meineLatitude!,
          _meineLongitude!,
          a.latitude!,
          a.longitude!,
        );
        return dist <= 50.0;
      }).toList();

      setState(() {
        _passendeAuftraege = gefiltert;
        _isLoading = false;
      });
    } on PostgrestException catch (e) {
      setState(() {
        _errorMessage = e.message;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _errorMessage = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Dienstleister Dashboard'),
        actions: [
          IconButton(
            icon: const Icon(Icons.person),
            onPressed: () async {
              await Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (_) => const p.ProfilDienstleisterScreen(),
                ),
              );
              _ladeProfilUndAuftraege();
            },
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: _isLoading
            ? const Center(child: CircularProgressIndicator())
            : _errorMessage != null
                ? Center(child: Text('Fehler: $_errorMessage'))
                : _passendeAuftraege.isEmpty
                    ? const Center(child: Text('Keine passenden Aufträge'))
                    : ListView.builder(
                        itemCount: _passendeAuftraege.length,
                        itemBuilder: (context, index) {
                          final auf = _passendeAuftraege[index];
                          final dist =
                              (auf.latitude != null && auf.longitude != null)
                                  ? berechneEntfernung(
                                          _meineLatitude!,
                                          _meineLongitude!,
                                          auf.latitude!,
                                          auf.longitude!)
                                      .toStringAsFixed(1)
                                  : '-';
                          return ListTile(
                            title: Text(auf.titel),
                            subtitle: Text('Entfernung: $dist km'),
                            onTap: () {
                              Navigator.push(
                                context,
                                MaterialPageRoute(
                                  builder: (_) => a.AuftragDetailScreen(
                                    initialAuftrag: auf,
                                  ),
                                ),
                              ).then((_) {
                                _ladeProfilUndAuftraege();
                              });
                            },
                          );
                        },
                      ),
      ),
    );
  }
}
```

### 5. KundenDashboardScreen

```dart
// lib/screens/kunden_dashboard_screen.dart

import 'package:flutter/material.dart';
import 'auftrag_erstellen_screen.dart';
import 'meine_auftraege_screen.dart';

class KundenDashboardScreen extends StatelessWidget {
  const KundenDashboardScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Kunden-Dashboard')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ElevatedButton.icon(
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(builder: (context) => const AuftragErstellenScreen()),
                );
              },
              icon: const Icon(Icons.add),
              label: const Text('Neuen Auftrag erstellen'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15),
              ),
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(builder: (context) => const MeineAuftraegeScreen()),
                );
              },
              icon: const Icon(Icons.assignment),
              label: const Text('Meine Aufträge'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

### 6. Login-Screens

#### login_dienstleister_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'dienstleister_dashboard_screen.dart';
import 'registrierung_screen.dart';

class LoginDienstleisterScreen extends StatefulWidget {
  const LoginDienstleisterScreen({Key? key}) : super(key: key);

  @override
  _LoginDienstleisterScreenState createState() => _LoginDienstleisterScreenState();
}

class _LoginDienstleisterScreenState extends State<LoginDienstleisterScreen> {
  final _emailController = TextEditingController(text: 'walterlangengries@gmail.com');
  final _passwortController = TextEditingController(text: 'password123');
  final _formKey = GlobalKey<FormState>();
  bool _isLoading = false;
  final supabase = Supabase.instance.client;

  Future<void> _login() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final AuthResponse authRes = await supabase.auth.signInWithPassword(
        email: _emailController.text.trim(),
        password: _passwortController.text,
      );
      final user = authRes.user;
      if (user == null) {
        throw AuthException('Login fehlgeschlagen. Bitte überprüfe deine Daten oder bestätige deine E-Mail.');
      }

      // 1. Prüfen, ob es bereits einen Eintrag in 'users' gibt
      final fetched = await supabase
          .from('users')
          .select('rolle')
          .eq('id', user.id)
          .maybeSingle();

      if (fetched == null) {
        // Kein Eintrag in 'users' → erster Login: Insert mit Rolle 'dienstleister'
        try {
          await supabase.from('users').insert({
            'id': user.id,
            'email': user.email,
            'rolle': 'dienstleister',
            'erstellt_am': DateTime.now().toIso8601String(),
          });
        } catch (e) {
          print('[DEBUG] Insert in users schlug fehl: $e');
        }
      } else if (fetched['rolle'] != 'dienstleister') {
        // Eintrag existiert, aber Rolle passt nicht
        await supabase.auth.signOut();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Dieser Account ist kein Dienstleister. Bitte nutze den Kunden-Login.'),
            backgroundColor: Colors.redAccent,
          ),
        );
        return;
      }

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Login erfolgreich!')),
      );
      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (context) => const DienstleisterDashboardScreen()),
      );
    } on AuthException catch (error) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Login fehlgeschlagen: ${error.message}')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Unbekannter Fehler: $e')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  String? _validateEmail(String? value) {
    if (value == null || value.isEmpty) return 'Bitte E-Mail eingeben';
    final emailRegex = RegExp(r'^[^@]+@[^@]+\.[^@]+');
    if (!emailRegex.hasMatch(value)) return 'Bitte eine gültige E-Mail eingeben';
    return null;
  }

  String? _validatePasswort(String? value) {
    if (value == null || value.isEmpty) return 'Bitte Passwort eingeben';
    if (value.length < 6) return 'Passwort muss mindestens 6 Zeichen lang sein';
    return null;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login für Dienstleister')),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              TextFormField(
                controller: _emailController,
                decoration: const InputDecoration(labelText: 'E-Mail'),
                keyboardType: TextInputType.emailAddress,
                validator: _validateEmail,
              ),
              const SizedBox(height: 20),
              TextFormField(
                controller: _passwortController,
                decoration: const InputDecoration(labelText: 'Passwort'),
                obscureText: true,
                validator: _validatePasswort,
              ),
              const SizedBox(height: 30),
              _isLoading
                  ? const CircularProgressIndicator()
                  : ElevatedButton(
                      onPressed: _login,
                      child: const Text('Login'),
                    ),
              TextButton(
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (context) => const RegistrierungScreen()),
                  );
                },
                child: const Text('Noch kein Konto? Jetzt registrieren'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

#### login_kunde_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'kunden_dashboard_screen.dart';
import 'registrierung_screen.dart';

class LoginKundeScreen extends StatefulWidget {
  const LoginKundeScreen({Key? key}) : super(key: key);

  @override
  _LoginKundeScreenState createState() => _LoginKundeScreenState();
}

class _LoginKundeScreenState extends State<LoginKundeScreen> {
  final _emailController = TextEditingController(text: 'quintenhessmann1995@yahoo.com');
  final _passwortController = TextEditingController(text: 'password123');
  final _formKey = GlobalKey<FormState>();
  bool _isLoading = false;
  final supabase = Supabase.instance.client;

  Future<void> _login() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final AuthResponse authRes = await supabase.auth.signInWithPassword(
        email: _emailController.text.trim(),
        password: _passwortController.text,
      );
      final user = authRes.user;
      if (user == null) {
        throw AuthException('Login fehlgeschlagen. Bitte überprüfe deine Daten oder bestätige deine E-Mail.');
      }

      // 1. Prüfen, ob es bereits einen Eintrag in 'users' gibt
      final fetched = await supabase
          .from('users')
          .select('rolle')
          .eq('id', user.id)
          .maybeSingle();

      if (fetched == null) {
        // Kein Eintrag in 'users' → erster Login: Insert mit Rolle 'kunde'
        try {
          await supabase.from('users').insert({
            'id': user.id,
            'email': user.email,
            'rolle': 'kunde',
            'erstellt_am': DateTime.now().toIso8601String(),
          });
        } catch (e) {
          print('[DEBUG] Insert in users schlug fehl: $e');
        }
      } else if (fetched['rolle'] != 'kunde') {
        // Eintrag existiert, aber Rolle passt nicht
        await supabase.auth.signOut();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Dieser Account ist kein Kunde. Bitte nutze den Dienstleister-Login.'),
            backgroundColor: Colors.redAccent,
          ),
        );
        return;
      }

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Login erfolgreich!')),
      );
      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (context) => const KundenDashboardScreen()),
      );
    } on AuthException catch (error) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Login fehlgeschlagen: ${error.message}')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Unbekannter Fehler: $e')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  String? _validateEmail(String? value) {
    if (value == null || value.isEmpty) return 'Bitte E-Mail eingeben';
    final emailRegex = RegExp(r'^[^@]+@[^@]+\.[^@]+');
    if (!emailRegex.hasMatch(value)) return 'Bitte eine gültige E-Mail eingeben';
    return null;
  }

  String? _validatePasswort(String? value) {
    if (value == null || value.isEmpty) return 'Bitte Passwort eingeben';
    if (value.length < 6) return 'Passwort muss mindestens 6 Zeichen lang sein';
    return null;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login für Kunden')),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              TextFormField(
                controller: _emailController,
                decoration: const InputDecoration(labelText: 'E-Mail'),
                keyboardType: TextInputType.emailAddress,
                validator: _validateEmail,
              ),
              const SizedBox(height: 20),
              TextFormField(
                controller: _passwortController,
                decoration: const InputDecoration(labelText: 'Passwort'),
                obscureText: true,
                validator: _validatePasswort,
              ),
              const SizedBox(height: 30),
              _isLoading
                  ? const CircularProgressIndicator()
                  : ElevatedButton(
                      onPressed: _login,
                      child: const Text('Login'),
                    ),
              TextButton(
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (context) => const RegistrierungScreen()),
                  );
                },
                child: const Text('Noch kein Konto? Jetzt registrieren'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

### 7. MeineAuftraegeScreen

```dart
// lib/screens/meine_auftraege_screen.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/auftrag.dart';
import 'auftrag_detail_screen.dart';

class MeineAuftraegeScreen extends StatefulWidget {
  const MeineAuftraegeScreen({Key? key}) : super(key: key);

  @override
  _MeineAuftraegeScreenState createState() => _MeineAuftraegeScreenState();
}

class _MeineAuftraegeScreenState extends State<MeineAuftraegeScreen> {
  final supabase = Supabase.instance.client;
  List<Map<String, dynamic>> _auftraege = [];
  bool _isLoading = true;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _ladeAuftraege();
  }

  Future<void> _ladeAuftraege() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final user = supabase.auth.currentUser;
      if (user == null) throw Exception('Nicht eingeloggt');
      final response = await supabase
          .from('auftraege')
          .select()
          .eq('kunde_id', user.id)
          .order('erstellt_am', ascending: false);
      setState(() {
        _auftraege = (response as List).cast<Map<String, dynamic>>();
        _isLoading = false;
      });
    } on PostgrestException catch (e) {
      setState(() {
        _errorMessage = e.message;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _errorMessage = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Meine Aufträge'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _ladeAuftraege,
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: _isLoading
            ? const Center(child: CircularProgressIndicator())
            : _errorMessage != null
                ? Center(child: Text('Fehler: $_errorMessage'))
                : _auftraege.isEmpty
                    ? const Center(child: Text('Keine Aufträge gefunden.'))
                    : ListView.builder(
                        itemCount: _auftraege.length,
                        itemBuilder: (context, index) {
                          final auftragMap = _auftraege[index];
                          final auftrag = Auftrag.fromJson(auftragMap);
                          return ListTile(
                            title: Text(auftrag.titel),
                            subtitle: Text('Kategorie: ${auftrag.kategorie}  •  Status: ${auftrag.status}'),
                            trailing: const Icon(Icons.arrow_forward_ios, size: 16),
                            onTap: () {
                              Navigator.push(
                                context,
                                MaterialPageRoute(
                                  builder: (_) => AuftragDetailScreen(initialAuftrag: auftrag),
                                ),
                              );
                            },
                          );
                        },
                      ),
      ),
    );
  }
}
```

### 8. ProfilDienstleisterScreen

```dart
// lib/screens/profil_dienstleister_screen.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:atyourservice/utils/geocoding_service.dart';

class ProfilDienstleisterScreen extends StatefulWidget {
  const ProfilDienstleisterScreen({Key? key}) : super(key: key);

  @override
  _ProfilDienstleisterScreenState createState() =>
      _ProfilDienstleisterScreenState();
}

class _ProfilDienstleisterScreenState
    extends State<ProfilDienstleisterScreen> {
  final _supabase = Supabase.instance.client;
  final _formKey = GlobalKey<FormState>();

  // Controller für Formular-Felder
  final _nameController = TextEditingController();
  final _beschreibungController = TextEditingController();
  String _selectedKategorie = 'Elektriker';
  final _adresseController = TextEditingController();
  final _telefonController = TextEditingController();
  final _emailController = TextEditingController()..text = '@';

  bool _isLoading = false;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _ladeProfil();
  }

  Future<void> _ladeProfil() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final user = _supabase.auth.currentUser;
      if (user == null) throw Exception('Bitte zuerst einloggen');

      // Prüfen, ob es schon ein Profil gibt
      final data = await _supabase
          .from('dienstleister_details')
          .select(
            'name, beschreibung, kategorie, adresse, latitude, longitude, telefon, email',
          )
          .eq('user_id', user.id)
          .maybeSingle();

      if (data != null) {
        _nameController.text = data['name'] as String? ?? '';
        _beschreibungController.text =
            data['beschreibung'] as String? ?? '';
        _selectedKategorie = data['kategorie'] as String? ?? 'Elektriker';
        _adresseController.text = data['adresse'] as String? ?? '';
        _telefonController.text = data['telefon'] as String? ?? '';
        final existingEmail = data['email'] as String? ?? '';
        _emailController.text =
            existingEmail.isNotEmpty ? existingEmail : '@';
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'Fehler beim Laden des Profils: $e';
      });
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  Future<void> _profilSpeichern() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final user = _supabase.auth.currentUser;
      if (user == null) throw Exception('Bitte zuerst einloggen');

      final name = _nameController.text.trim();
      final beschreibung = _beschreibungController.text.trim();
      final kategorie = _selectedKategorie;
      final adresse = _adresseController.text.trim();
      final telefon = _telefonController.text.trim();
      final email = _emailController.text.trim();

      double? lat, lon;
      if (adresse.isNotEmpty) {
        final coords = await GeocodingService().getCoordinates(adresse);
        if (coords == null) throw Exception('Adresse nicht gefunden.');
        lat = coords['lat'];
        lon = coords['lng'];
      }

      // ─── Erste Prüfung: Logge die Auth-User-ID ───
      print('▶ Auth-User-ID: ${user.id}');

      // ─── Zweite Prüfung: Logge das gesamte Payload, das gleich geschickt wird ───
      final payload = {
        'user_id': user.id,
        'name': name,
        'beschreibung': beschreibung,
        'kategorie': kategorie,
        'adresse': adresse.isEmpty ? null : adresse,
        'latitude': lat,
        'longitude': lon,
        'telefon': telefon,
        'email': email,
        'aktualisiert_am': DateTime.now().toUtc().toIso8601String(),
      };
      print('▶ payload für Upsert: $payload');

      // ─── Dann kommt das Upsert wie gehabt ───
      await _supabase
          .from('dienstleister_details')
          .upsert(payload, onConflict: 'user_id')
          .select()
          .single();

      // Wenn kein Exception geworfen wurde, war das Upsert erfolgreich
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Profil wurde erfolgreich aktualisiert!'),
        ),
      );
    } catch (e) {
      setState(() {
        _errorMessage = e.toString().replaceFirst('Exception: ', '');
      });
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _beschreibungController.dispose();
    _adresseController.dispose();
    _telefonController.dispose();
    _emailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Dienstleister-Profil')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: _isLoading
            ? const Center(child: CircularProgressIndicator())
            : SingleChildScrollView(
                child: Form(
                  key: _formKey,
                  child: Column(
                    children: [
                      TextFormField(
                        controller: _nameController,
                        decoration: const InputDecoration(labelText: 'Name'),
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Bitte Name eingeben';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _beschreibungController,
                        decoration:
                            const InputDecoration(labelText: 'Beschreibung'),
                        maxLines: 3,
                      ),
                      const SizedBox(height: 16),
                      DropdownButtonFormField<String>(
                        value: _selectedKategorie,
                        decoration:
                            const InputDecoration(labelText: 'Kategorie'),
                        items: const [
                          DropdownMenuItem(
                              value: 'Elektriker', child: Text('Elektriker')),
                          DropdownMenuItem(
                              value: 'Klempner', child: Text('Klempner')),
                          DropdownMenuItem(value: 'Maler', child: Text('Maler')),
                        ],
                        onChanged: (wert) {
                          if (wert != null) {
                            setState(() {
                              _selectedKategorie = wert;
                            });
                          }
                        },
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Bitte Kategorie auswählen';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _adresseController,
                        decoration: const InputDecoration(
                          labelText: 'Adresse (z. B. Straße, PLZ, Stadt)',
                        ),
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _telefonController,
                        decoration:
                            const InputDecoration(labelText: 'Telefonnummer'),
                        keyboardType: TextInputType.phone,
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _emailController,
                        decoration: const InputDecoration(labelText: 'E-Mail'),
                        keyboardType: TextInputType.emailAddress,
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Bitte E-Mail eingeben';
                          }
                          final emailRegex =
                              RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+\$');
                          if (!emailRegex.hasMatch(value)) {
                            return 'Bitte gültige E-Mail eingeben';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 24),
                      if (_errorMessage != null) ...[
                        Text(
                          'Fehler: $_errorMessage',
                          style: const TextStyle(color: Colors.red),
                        ),
                        const SizedBox(height: 12),
                      ],
                      ElevatedButton(
                        onPressed: _profilSpeichern,
                        child: const Text('Profil speichern'),
                      ),
                    ],
                  ),
                ),
              ),
      ),
    );
  }
}
```

### 9. RegistrierungScreen

```dart
// lib/screens/registrierung_screen.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class RegistrierungScreen extends StatefulWidget {
  const RegistrierungScreen({Key? key}) : super(key: key);

  @override
  State<RegistrierungScreen> createState() => _RegistrierungScreenState();
}

class _RegistrierungScreenState extends State<RegistrierungScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController(text: 'quintenhessmann1995@yahoo.com');
  final _passwordController = TextEditingController(text: 'password123');
  String _rolle = 'kunde';
  bool _isLoading = false;

  final supabase = Supabase.instance.client;

  Future<void> _registrieren() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() => _isLoading = true);
    final email = _emailController.text.trim();
    final password = _passwordController.text;

    try {
      // 1. Überprüfen, ob die E-Mail bereits registriert ist:
      //    Wir versuchen, uns mit einem Dummy-Passwort einzuloggen.
      //    Wenn AuthException geworfen wird:
      //      - "Invalid login credentials" ⇒ E-Mail existiert, aber falsches Passwort.
      //      - "User not found" ⇒ E-Mail existiert nicht (kann neu registriert werden).
      //      - andere Fehlermeldung ⇒ entsprechend behandeln.
      await supabase.auth.signInWithPassword(
        email: email,
        password: '••••••••', // Dummy-Passwort für den Existenz-Check
      );
      // Wenn kein AuthException geworfen wurde, konnte man sich tatsächlich einloggen ⇒ Konto existiert mit diesem Passwort.
      // Wir loggen den Nutzer sofort wieder aus und zeigen eine Fehlermeldung an.
      await supabase.auth.signOut();

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Diese E-Mail ist bereits registriert. Bitte einloggen.')),
      );
    } on AuthException catch (authError) {
      final err = authError.message.toLowerCase();
      if (err.contains('invalid login credentials')) {
        // E-Mail existiert, aber falsches Passwort
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Diese E-Mail ist bereits registriert. Passwort vergessen?')),
        );
      } else if (err.contains('user not found')) {
        // E-Mail existiert nicht ⇒ sicher zum Signup weitermachen
        await _signUpFlow(email, password);
      } else {
        // andere AuthException (z.B. Netzwerkfehler)
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Fehler beim Überprüfen: ${authError.message}')),
        );
      }
    } catch (e) {
      // Alle anderen Fehler (z. B. Netzwerk-Timeout)
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Unbekannter Fehler: $e')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _signUpFlow(String email, String password) async {
    try {
      await supabase.auth.signUp(email: email, password: password);
      // Registrierung erfolgreich (egal ob Bestätigungsmail verschickt wurde oder nicht)
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text(
            'Registrierung erfolgreich! Bitte überprüfe deine E-Mail und bestätige sie.',
          ),
        ),
      );
      Navigator.of(context).pop();
    } on AuthException catch (authError) {
      // Sollte normalerweise hier nicht "E-Mail existiert bereits" sein, da wir das vorher abgefangen haben.
      final err = authError.message.toLowerCase();
      String userMessage;
      if (err.contains('already registered') ||
          err.contains('duplicate') ||
          err.contains('user exists')) {
        userMessage = 'Diese E-Mail ist bereits registriert.';
      } else if (err.contains('invalid email')) {
        userMessage = 'Bitte gib eine gültige E-Mail-Adresse ein.';
      } else if (err.contains('password')) {
        userMessage = 'Passwort muss mindestens 6 Zeichen haben.';
      } else {
        userMessage = 'Registrierung fehlgeschlagen: ${authError.message}';
      }
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(userMessage)),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Unbekannter Fehler: $e')),
      );
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Registrierung')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              // Rollenwahl (Kunde / Dienstleister)
              DropdownButtonFormField<String>(
                value: _rolle,
                decoration: const InputDecoration(labelText: 'Rolle auswählen'),
                items: const [
                  DropdownMenuItem(value: 'kunde', child: Text('Kunde')),
                  DropdownMenuItem(value: 'dienstleister', child: Text('Dienstleister')),
                ],
                onChanged: (value) {
                  if (value != null) {
                    setState(() => _rolle = value);
                  }
                },
              ),
              const SizedBox(height: 16),

              // E-Mail-Feld
              TextFormField(
                controller: _emailController,
                decoration: const InputDecoration(labelText: 'E-Mail'),
                keyboardType: TextInputType.emailAddress,
                validator: (value) {
                  if (value == null || value.isEmpty) return 'Bitte E-Mail eingeben';
                  if (!RegExp(r'\S+@\S+\.\S+').hasMatch(value)) {
                    return 'Bitte gültige E-Mail eingeben';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),

              // Passwort-Feld
              TextFormField(
                controller: _passwordController,
                decoration: const InputDecoration(labelText: 'Passwort'),
                obscureText: true,
                validator: (value) {
                  if (value == null || value.isEmpty) return 'Bitte Passwort eingeben';
                  if (value.length < 6) return 'Passwort muss mindestens 6 Zeichen haben';
                  return null;
                },
              ),
              const SizedBox(height: 32),

              // Registrieren-Button
              _isLoading
                  ? const CircularProgressIndicator()
                  : ElevatedButton(
                      onPressed: _registrieren,
                      child: const Text('Registrieren'),
                    ),
            ],
          ),
        ),
      ),
    );
  }
}
```

### 10. StartScreen

```dart
// lib/screens/start_screen.dart

import 'package:flutter/material.dart';
import 'login_kunde_screen.dart';
import 'login_dienstleister_screen.dart';

class StartScreen extends StatelessWidget {
  const StartScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('atyourservice')),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ElevatedButton(
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => const LoginKundeScreen()),
                  );
                },
                child: const Text('Ich suche Hilfe (Kunde)'),
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => const LoginDienstleisterScreen()),
                  );
                },
                child: const Text('Ich biete Hilfe an (Dienstleister)'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

### 11. Dienstleister-Beispieldaten (statisch, nur testweise)

```dart
// lib/models/dienstleister_testdaten.dart

import '../models/dienstleister.dart';

List<Dienstleister> dienstleisterDaten = [
  Dienstleister(
    id: 'd1',
    name: 'Maler Max',
    kategorie: 'Maler',
    latitude: 52.5200,
    longitude: 13.4050, // Berlin
    zuletztOnline: DateTime.now().subtract(Duration(minutes: 3)),
  ),
  Dienstleister(
    id: 'd2',
    name: 'Elektriker Erika',
    kategorie: 'Elektriker',
    latitude: 52.5000,
    longitude: 13.4100, // Nähe Berlin
    zuletztOnline: DateTime.now().subtract(Duration(minutes: 25)),
  ),
  Dienstleister(
    id: 'd3',
    name: 'Klempner Klaus',
    kategorie: 'Klempner',
    latitude: 48.1351,
    longitude: 11.5820, // München
    zuletztOnline: DateTime.now().subtract(Duration(minutes: 58)),
  ),
  Dienstleister(
    id: 'd4',
    name: 'Malerin Mona',
    kategorie: 'Maler',
    latitude: 52.5190,
    longitude: 13.4000, // Nähe Berlin
    zuletztOnline: DateTime.now().subtract(Duration(minutes: 8)),
  ),
];
```

### 12. EntfernungUtils

```dart
// lib/utils/entfernung_utils.dart

import 'dart:math';

double berechneEntfernung(double lat1, double lon1, double lat2, double lon2) {
  const double erdRadius = 6371; // in Kilometern

  double dLat = _gradZuBogenmass(lat2 - lat1);
  double dLon = _gradZuBogenmass(lon2 - lon1);

  double a = sin(dLat / 2) * sin(dLat / 2) +
      cos(_gradZuBogenmass(lat1)) *
          cos(_gradZuBogenmass(lat2)) *
          sin(dLon / 2) *
          sin(dLon / 2);
  double c = 2 * atan2(sqrt(a), sqrt(1 - a));
  double entfernung = erdRadius * c;

  return entfernung;
}

double _gradZuBogenmass(double grad) {
  return grad * pi / 180;
}
```

### 13. GeocodingService

```dart
// lib/utils/geocoding_service.dart

import 'dart:convert';
import 'package:http/http.dart' as http;

class GeocodingService {
  /// Ruft OpenStreetMap Nominatim an, um aus einer Adresse
  /// Breiten- und Längengrad zu bekommen.
  Future<Map<String, double>?> getCoordinates(String address) async {
    // URL für Nominatim: format=json, limit=1 → nur das erste Ergebnis
    final uri = Uri.parse(
      'https://nominatim.openstreetmap.org/search'
      '?format=json&limit=1&q=${Uri.encodeComponent(address)}',
    );

    try {
      final response = await http.get(
        uri,
        headers: {
          // User-Agent laut Nominatim-Vorgabe (eigene App/Mail einsetzen)
          'User-Agent': 'atyourservice-FlutterApp/1.0 (meine@mailadresse.de)',
        },
      );

      if (response.statusCode == 200) {
        final List<dynamic> data = json.decode(response.body);
        if (data.isNotEmpty) {
          final first = data[0] as Map<String, dynamic>;
          final lat = double.tryParse(first['lat'] as String);
          final lon = double.tryParse(first['lon'] as String);
          if (lat != null && lon != null) {
            return {'lat': lat, 'lng': lon};
          }
        }
      }
    } catch (_) {
      // Bei Fehlern geben wir null zurück
    }
    return null;
  }
}
```

### 14. SupabaseClientManager / main.dart

```dart
// lib/utils/supabase_client.dart

import 'package:supabase_flutter/supabase_flutter.dart';

class SupabaseClientManager {
  static final SupabaseClient client = Supabase.instance.client;

  static Future<void> init() async {
    await Supabase.initialize(
      url: 'https://npqanssmfxdvwauuaemd.supabase.co',
      anonKey: 'eyJhbGciOiJIUzI1NiIsInR...WHc',
    );
  }
}

// lib/main.dart

import 'package:flutter/material.dart';
import 'utils/supabase_client.dart'; // Supabase Client Manager
import 'screens/start_screen.dart';  // StartScreen importieren

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await SupabaseClientManager.init(); // Supabase initialisieren
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Mein Handwerker-App',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.deepPurple,
          secondary: Colors.deepPurpleAccent,
        ),
        scaffoldBackgroundColor: Colors.grey[100],
        appBarTheme: const AppBarTheme(
          backgroundColor: Colors.deepPurple,
          foregroundColor: Colors.white,
          elevation: 2,
          titleTextStyle: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.deepPurple,
            foregroundColor: Colors.white,
            textStyle: const TextStyle(fontSize: 18, fontWeight: FontWeight.w600),
            minimumSize: const Size(250, 55),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
          ),
        ),
        textTheme: const TextTheme(
          bodyMedium: TextStyle(fontSize: 16, color: Colors.black87),
          headlineSmall: TextStyle(fontWeight: FontWeight.bold),
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
          ),
          focusedBorder: OutlineInputBorder(
            borderSide: const BorderSide(color: Colors.deepPurple),
            borderRadius: BorderRadius.circular(10),
          ),
          labelStyle: const TextStyle(color: Colors.deepPurple),
        ),
      ),
      home: const StartScreen(),
    );
  }
}

class SupabaseTestScreen extends StatelessWidget {
  const SupabaseTestScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Supabase Test')),
      body: Center(
        child: ElevatedButton(
          child: const Text('Teste Supabase Verbindung'),
          onPressed: () async {
            try {
              final data = await SupabaseClientManager.client
                  .from('users')
                  .select()
                  .maybeSingle();

              if (data == null) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Keine Nutzer gefunden')),
                );
              } else if (data is List) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('Erfolg! Anzahl Nutzer: ${data.length}')),
                );
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Erfolg! Nutzer gefunden')),
                );
              }
            } catch (error) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Fehler: $error')),
              );
            }
          },
        ),
      ),
    );
  }
}
```

---

## 15. Zusammenfassung des Problems
- Aktuell sieht der Kunde in **AuftragDetailScreen** nicht die Kontaktdaten des Dienstleisters, obwohl:
  1. Der Auftrag den Status „in bearbeitung“ hat,
  2. `dienstleister_id` korrekt auf die DL‐User‐ID gesetzt wurde,
  3. Ein Eintrag in `dienstleister_details` für diese ID existiert (Telefon und E-Mail sind eingetragen),
  4. Und im SQL‐Editor `SELECT * FROM dienstleister_details WHERE user_id = <DL‐ID>` eine Zeile zurückgibt.

- Das leere Ergebnis („Dienstleisterkontakt:“ bleibt leer) deutet darauf hin, dass die momentane Logik im Code entweder:
  1. Die verschachtelte `select('… kunde:users!… dienstleister:users!…')`‐Abfrage nicht korrekt ausgewertet wird, oder
  2. Die Felder `_dlTelefon` und `_dlEmail` nie gesetzt werden, weil die Abfrage gar nicht getriggert wird.

- **Lösungsvorschlag** (neuer Chat):  
  1. Ein einzelnes `select(...)` auf **`auftraege`** ohne Joins absetzen (inkl. `telefon`, `kunde_id`, `dienstleister_id`).  
  2. Falls `status == 'in bearbeitung'`, jeweils separat:
     - Aus `users` die E-Mail abrufen (Filter auf `id = <dienstleister_id>`).  
     - Aus `dienstleister_details` die Telefonnummer abrufen (Filter auf `user_id = <dienstleister_id>`).  
  3. Mit `print(...)`-Statements debuggen, um zu erkennen, ob beide Abfragen Daten liefern.  
  4. Falls keine Daten kommen: Manuell in der Supabase‐Console per SQL‐Insert einen Test‐Datensatz in `dienstleister_details` anlegen, damit das Ergebnis im Kunden-View sichtbar wird.

---

**Das ist der Stand und die Zusammenfassung all unserer bisherigen Anpassungen.**

Bitte speichere diese Datei (z. B. als `zusammenfassung_neuer_chat.txt`) und lade sie herunter. Dann können wir im neuen Chat sofort dort weitermachen, wo wir aufgehört haben.

